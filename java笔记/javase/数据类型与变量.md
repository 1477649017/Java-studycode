#  数据类型与变量

#  一，字面常量

**定义：常量即程序运行期间，固定不变的量称为常量。**

字面常量的分类：

1. 字符串常量：由""括起来的，比如“12345”、“hello”、“你好”。
2. 整形常量：程序中直接写的数字(注意没有小数点)，比如：100、1000
3. 浮点数常量：程序中直接写的小数，比如：3.14、0.49
4. 字符常量：由 单引号 括起来的当个字符，比如：‘A’、‘1’
5. 布尔常量：**只有两种true和false**
6. 空常量：null



****



#  二，数据类型(这里重点关注基本数据类型)

##  2.1，Java数据类型总体概览

&emsp;**Java的基本数据类型一共四类八种**

![image-20220420101943903](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20220420101943903.png) 

****



##  2.2，详细介绍图解

![image-20220420103302944](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20220420103302944.png)

**注意：**

1. **不论是在16位系统还是32位系统，int都占用4个字节，long都占8个字节，在Java中这是规定死的。**
2.  **整形和浮点型都是带有符号的，char型不能表示负数。**
3.  **整型默认为int型，浮点型默认为double**

****



#  三，变量

**定义：在程序运行过程中可变的量就叫做变量。**

##  3.1，整形变量

###  3.1.1，普通整形

```java
public class TestDemo {
    public static void main(String[] args) {
        int a = Integer.MAX_VALUE;
        int b = Integer.MAX_VALUE + 1;
        System.out.println(a);
        System.out.println(b);
        int c = 10;
        System.out.println(c);

    }
}
```

**代码运行截图：**

![image-20220420110050379](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20220420110050379.png )  

****

**注意点：**

1，首先，整形的变量的大小就是4个字节，在Java中其大小是规定好的，不会因为操作系统不同而不同

2，整形的数据都是有符号的，在Java中没有无符号数这个概念。所以最高位为符号位的话，int类型的数据表示的范围就为  -2^31 ---- 2^31 - 1

3，在给int类型赋值的时候，你所传的字面常量的值不能超过int的范围，不然会直接报错。

4，对于每一个基本数据类型而言，都会有一个包装类与其对应，在现阶段我们就可以将包装类理解为这个数据类型的一个plus版本，里面包含着很多有关这个数据类型的方法。

这个有最容易和C语言混淆的一个点，问大家一个问题，在Java里面，如果一个局部变量不初始化会怎么样？

 A:不输出任何值    B:输出随机值   C:程序编译错误

这里如果大家先入为主，联想到C语言的话，可能就会直接说是输出随机值。但是一定记住，在Java里面，是十分严格的，你不给局部变量初始化值，那么使用时就会直接报错，编译错误！

****

**既然说到了局部变量，这里也就还补充一点，就是在Java里面，没有全局变量的说法，只是对于那些在类里面，方法外面的变量，我们称之为成员。**

****



###  3.1.2，长整形

```java
public class TestDemo {
    public static void main(String[] args) {
        long unm = 10L;//定义长整形后面必须要加上一个L，最好用大写
        System.out.println("长整型最大值 ：" + Long.MAX_VALUE );
        System.out.println("长整型最小值 ：" + Long.MIN_VALUE);
    }
}
```

**代码运行截图：**

![image-20220420112928546](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20220420112928546.png ) 

**注意点：**

1，首先，长整型的长度就是8个字节，规定好的。

2，在长整型变量定义的时候你要与普通的整形区分，所以后面要加L，这里最好是用大写，因为小写很容易弄混淆。

3，长整型的表示范围是 -2^63 ---- 2^63 - 1。

4，长整形对应的包装类是Long.

****



###  3.1.3，短整型

```java
public class TestDemo {
    public static void main(String[] args) {
        short num = 10;
        System.out.println("短整型最大值 ：" + Short.MAX_VALUE );
        System.out.println("短整型最小值 ：" + Short.MIN_VALUE);
    }
}
```

**代码运行截图：**

![image-20220420115337889](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20220420115337889.png) 

**注意点：**

1. 首先，short在任何系统下都占2个字节，规定好的。
2. short的表示范围为：-2^15 ---- 2^15 - 1。
3. 使用时注意不要超过范围(一般使用比较少)
4. short的包装类型为Short

****



###  3.1.4，字节型

```java
public class TestDemo {
    public static void main(String[] args) {
        byte a = 10;
        System.out.println("字节型最大值 ：" + Byte.MAX_VALUE );
        System.out.println("字节型最小值 ：" + Byte.MIN_VALUE);
    }
}
```

**代码运行截图：**

![image-20220420121143201](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20220420121143201.png) 

**注意点：**

1. byte在任何系统下都占1个字节
2. byte的范围是：-2^7 ---- 2^7 - 1。
3. 字节的包装类型为Byte

**小问题：大家看下这段代码**

```java
public class TestDemo {
    public static void main(String[] args) {
        byte num = 127;
        byte snum = (byte)(num + 1);
        System.out.println(snum);
    }
}
```

这段代码的输出结果是 -128，这里的原理其实和C中的char型数据以有符号的形式打印128的原理是一样的，其实就是加1整形提升后，类型强转发生截断，这个原理对于其他数据类型也是一样的，我们可以将某一个类型的数据的范围看成是一个圆圈，可以直接从正数最大直接跳到负数最小。当然，如果还有同学不明白的话，这里给大家推荐一篇文章，可以去康康哦，我觉得讲的还是很清楚的。

传送门：[(343条消息) 浅析为什么 char 类型的范围是 : -128~+127_Mike江的博客-CSDN博客](https://blog.csdn.net/tennysonsky/article/details/47035215)

最后，其实这个代码还有一点要告诉大家的是，在Java里面，如果你给某个类型的变量直接赋值字面常量的时候，一定要注意是不能超出这个类型的范围的，编译器会自己主动检查，超出就会直接报错，如果你非要拿这个数放到这个类型的变量里面去，可以参考上面的代码，利用一个变量中转，因为变量的值只有到运行的时候才会知道是几，这个时候就算是超过了范围，但是我们也是进行了强转，强制性的让它能够放的进这个类型的变量中。

****



##  3.2，浮点型常量

**对于浮点型的常量而言，有两种，单精度float与双精度double**

```java
public class TestDemo {
    public static void main(String[] args) {
        float num = 1.2f;
        System.out.println(num);
        
        double num1 = 1.1;
        System.out.println(num1);

        double num2 = num1*num1;
        System.out.println(num2);
    }
}
```

**程序运行截图：**

![image-20220420151507861](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20220420151507861.png) 



**注意：**

1. double在任何系统下都占8个字节,float占四个字节。

2. 浮点数与整数在内存中的存储方式不同，不能单纯使用2^n 的形式来计算，Java中浮点型的存储也遵循IEEE 754的标准。

3. double的包装类型为Double，float的包装类型为Float。

4. 因为float,double 类型的内存布局遵守 IEEE 754 标准(和C语言一样), 尝试使用有限的内存空间表示可能无限的小数, 势
    必会存在一定的精度误差，因此浮点数是个近似值，并不是精确值。所以，这里也告诉大家一点，PDD那玩意搞不得，谁

  知道小数后面到底还有多少位哦。

5. float精确到小数点后六位，double精确到小数点后15~16位。

**最后，再说明一点，我们一般使用都是推荐使用double类型，因为精度更加准确。**

****



##  3.3，字符型常量

```java
public class TestDemo {
    public static void main(String[] args) {
       char ch1 = 'a';
       char ch2 = '王';
       char ch3 = 97;
       System.out.println(ch1);
       System.out.println(ch2);
       System.out.println(ch3);
    }
}
```

**程序运行截图：**

![image-20220420154001365](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20220420154001365.png) 

**注意：**

1，char型是字符型，不属于整数类型

2，char型占2个字节，不能表示负数，所以字符对应的值的范围是0~2^16 - 1（65535）

3，因为字符型常量的范围是0~65535，范围很广，所以Java里面是使用Unicode字符集来进行对应的，相对于Ascii码字符集而言，Unicode包含Ascii码字符集，可以表示数字，英文字母，以及其他国家的字符等等。所以在这里我们可以直接将汉字赋值给一个字符型常量。(IDEA默认的编码格式是GBK,中文字符占两个字节)

4，char型的包装类是Character

****



##  3.4，布尔类型

```j
public class TestDemo {
    public static void main(String[] args) {
       boolean flg1  = true;
       boolean flg2 = false;
        System.out.println(flg1);
        System.out.println(flg2);
    }
}
```

**程序运行截图：**

![image-20220420160629773](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20220420160629773.png) 

**注意：**

1，在Java里面，没有什么非0表示真，0表示假，boolean的值就只有true，false。

2，JVM没有明确规定boolean类型的数据到底占几个字节，所以一般我们不讨论其大小问题。

3，boolean的包装类是Boolean。

****



#  四，类型转换

##  4.1，自动类型转换(隐式)

**自动类型转换即：代码不需要经过任何处理，在代码编译时，编译器会自动进行处理。特点：数据范围小的转为数 据范围大的时会自动进行，也就是精度进行了提升**

```java
public class TestDemo {
    public static void main(String[] args) {
       int num1 = 10;
       long num2 = 100L;
       num2 = num1;
        
       byte b1 = 100; // 编译通过，100没有超过byte的范围，编译器隐式将100转换为byte
       byte b2 = 257; // 编译失败，257超过了byte的数据范围，有数据丢失
 
    }
}
```

**注意：**

自动类型转换首先是小范围的会自动向大范围的数进行转化，然后就是我们在进行字面型常量赋值的时候，只要是没有超过这个类型的范围，那么都会自动的转换为该类型。

这里有人可能会有疑问，后面的100，257不都是四个字节吗？byte一个字节装不下，怎么不报错？

因为我们在用字面型常量进行赋值的时候，JVM检查的只是你的这个常量有没有超范围，而不是放不放的下的问题，并且换句话说，如果没有超范围，也就是说明就算截断也不会影响值，所以是不会有问题的，我们关心的点就是超没有超范围就行。



##  4.3，强制类型转换

**强制类型转换：当进行操作时，代码需要经过一定的格式处理，不能自动完成。特点：数据范围大的到数据范围小 的，也即是强制性的降低了精度。**

```java
public class TestDemo {
    public static void main(String[] args) {
        int num1 = 10;
        float num2 = 1.2f;
        num1 = (int)(num2);//虽然都是四个字节，但是float还有小数位，范围更广，必须强转。
        
        byte b1 = 100; // 100默认为int，没有超过byte范围，隐式转换
        byte b2 = (byte)257; // 257默认为int，超过byte范围，需要显示转换，否则报错
    }
```

**注意：**

在进行强制类型转换时，第一种就是高精度要赋值给低精度，二就是字面型常量超范围了只能强制转化。强制类型转换是程序员强制按照意愿进行的，所以也就是说要对结果负责，在进行强转之前一定要想清楚强转后到底影响大不大。

****

##  4.4，类型转换总结：

**类型转换注意事项总览：**

1. 不同数字类型的变量之间赋值, 表示范围更小的类型能隐式转换成范围较大的类型
2. 如果需要把范围大的类型赋值给范围小的, 需要强制类型转换, 但是可能精度丢失
3. 将一个字面值常量进行赋值的时候, Java 会自动针对数字范围进行检查
4. 强制类型转换不一定能成功，不相干的类型不能互相转换

*****



##  4.5，类型提升

```
public class TestDemo {
    public static void main(String[] args) {
        byte a = 10;
        byte b = 20;
        byte c = (byte)(a + b);//必须强转，不然报错
        System.out.println(c);
    }
}
```

解析：这段代码是因为两个byte型的数据相加会先提升到int型，所以最后的结果是int类型，要赋值给byte类型不兼容，必须强制类型转换。(由于计算机的 CPU 通常是按照 4 个字节为单位从内存中读写数据. 为了硬件上实现方便, 诸如 byte 和 short 这种低于 4 个字节的类型, 会先提升成 int, 再参与计算.)

**如上，就是我们提到的类型提升,一般情况下，四个字节以下的，也即是short,byte,char之间或者自身之间做运算，都是先提升到int型，大于四个字节的做运算，都是往精度高的做类型提升。**

![image-20220420165731956](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20220420165731956.png) 

****



##  4.6，例题分析

```
/**
 * Created with IntelliJ IDEA.
 * Description:
 * User: 14776
 * Date: 2022-04-21
 * Time: 10:07
 */
public class TestDemo220421 {
    public static void main(String[] args) {
        byte a = 127;
        byte b = (byte)(a + 1);
        System.out.println(b);

//        short c = 32767 + 1;这里是不行的，因为后面相加后是一个整形，前后类型不兼容，并且加起来的结果值也是超范围的
        short c = 32767;
        short d = (short)(c + 1);
        System.out.println(d);

        int e = 2_147_483_647 + 1;//为什么这里就可以这样写，因为前后都是整形，也就是说
//      对于某一个类型的变量，不存在整型提升以及前后等号两边类型相同的情况下，直接赋值一个超过范围的字面常量是不行的，但我们可以进行拆分后赋值
        System.out.println(e);

        long f = Long.MAX_VALUE + 1;
        System.out.println(f);
    }
}

```

**程序运行截图：**

![image-20220421105658887](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20220421105658887.png) 



#  五，字符串类型

在Java里面，字符串是一个类型。

初步的一些用法展示：

```
public class TestDemo {
    public static void main(String[] args) {
//        字符串转数字
        String str = "1234";
        int ret = Integer.parseInt(str);
        System.out.println(ret);
//         数字转字符串
        String str1 = String.valueOf(ret);
        System.out.println(str1);
//        字符串+的拼接
        int a = 10;
        int b = 20;
        System.out.println( a + b + "aaaaa");
        System.out.println("aaaaa" + a + b);
        System.out.println("aaaaa" + (a + b));

    }
}

```

**程序运行截图：**

![image-20220420173316245](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20220420173316245.png) 

这里我们可以初步的对于字符串类型的一些功能有些认识，在利用+号进行字符串的拼接的时候，要注意括号的问题，因为你要看你是想单个单个的结合，还是整体的进行结合，加不加括号的结果如上是不一样的。