#  从0开始刷力扣

#  一，数组类

##  1.1，数组的遍历

**题号：485，最大连续1的个数**

![image-20220520212821223](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20220520212821223.png) 

****

```java
class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        int count = 0;
        int max = 0;
        for(int i = 0;i < nums.length;i++){
            if(nums[i] == 1){
                count++;
            }else{
                count = 0;
            }
            if(count > max){
                max = count;
            }
        }
        return max;
    }
}
```

**这个题考察的就是数组的遍历以及你的观察能力，注意这是一个二进制的一维数组，正如提示里面所言，数组元素它不是0就是1，那我们要统计连续1的个数，遇到1就把count++，并且同步保存到max里面，如果数组元素为0了，就把count清零，又重新继续往后统计，当然之前max还是一直存储着遇到0之前的连续1的个数，后面只要又实时比较更新max就好了。**

***

**题号：495，提莫攻击**

![image-20220521195513348](C:\Users\14776\AppData\Roaming\Typora\typora-user-images\image-20220521195513348.png) 

```java
class Solution {
    public int findPoisonedDuration(int[] timeSeries, int duration) {
        int ret = 0;
        int end = 0;//记录理论上的中毒结束时间
        for(int i = 0;i < timeSeries.length;i++){
            if(timeSeries[i] >= end){
                ret += duration;
            }else{
                ret += timeSeries[i] + duration - end;
            }
            end = timeSeries[i] + duration;
        }
        return ret;
    }
}
```

***

其实这个问题也不要想的太过于复杂，就是一个中毒时间累加计算的问题，唯一需要我们注意的就是重置中毒效果的问题。我们每次收到一次攻击，中毒的时间就会是duration，所以我们先不考虑我们中间时间会有重叠的情况，先把所有的duration加起来，然后再把每次的重叠的部分减去，那最后就是我们的实际中毒时间了。

那把这个想法放到每一次攻击上，end是记载我们的理论中毒结束时间(不考虑中间受到攻击，以及end这个时刻其实不是中毒状态的)，所以是要我们的

timeSeries[i] >= end，那就不存在什么中间有重叠的情况，直接攻击了多少次，把duration累加就好，当然每算一次end就会更新，当不满足

timeSeries[i] >= end这个条件的时候，就说明在中毒生效的时间段类受到了攻击，所以这个时候按理来说我们的中毒持续时间不应该是duration了，因为中间重叠的应该减掉，那这个重叠的部分怎么算，就是timeSeries[i]  - end，这个算出来结果就是负的，加上的效果就是减了。

***

